// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDish = `-- name: CreateDish :one
INSERT INTO dishes (
    id,
    name,
    description,
    price,
    prep_time_minutes,
    available_on
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, name, description, price, prep_time_minutes, available_on, created_at, updated_at
`

type CreateDishParams struct {
	ID              pgtype.UUID    `db:"id" json:"id"`
	Name            string         `db:"name" json:"name"`
	Description     pgtype.Text    `db:"description" json:"description"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	PrepTimeMinutes int32          `db:"prep_time_minutes" json:"prep_time_minutes"`
	AvailableOn     pgtype.Date    `db:"available_on" json:"available_on"`
}

func (q *Queries) CreateDish(ctx context.Context, arg CreateDishParams) (Dish, error) {
	row := q.db.QueryRow(ctx, createDish,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.PrepTimeMinutes,
		arg.AvailableOn,
	)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.PrepTimeMinutes,
		&i.AvailableOn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (id, user_id, order_id, message)
VALUES ($1, $2, $3, $4) RETURNING id, user_id, order_id, message, sent_at
`

type CreateNotificationParams struct {
	ID      pgtype.UUID `db:"id" json:"id"`
	UserID  pgtype.UUID `db:"user_id" json:"user_id"`
	OrderID pgtype.UUID `db:"order_id" json:"order_id"`
	Message string      `db:"message" json:"message"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.ID,
		arg.UserID,
		arg.OrderID,
		arg.Message,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.Message,
		&i.SentAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (id, user_id, dish_id, status)
VALUES ($1, $2, $3, $4) RETURNING id, user_id, dish_id, status, created_at, updated_at
`

type CreateOrderParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	DishID pgtype.UUID `db:"dish_id" json:"dish_id"`
	Status string      `db:"status" json:"status"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.UserID,
		arg.DishID,
		arg.Status,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DishID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, name, email)
VALUES ($1, $2, $3) RETURNING id, name, email, created_at
`

type CreateUserParams struct {
	ID    pgtype.UUID `db:"id" json:"id"`
	Name  string      `db:"name" json:"name"`
	Email string      `db:"email" json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.ID, arg.Name, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDish = `-- name: DeleteDish :exec
DELETE FROM dishes
WHERE id = $1
`

func (q *Queries) DeleteDish(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDish, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getDish = `-- name: GetDish :one
SELECT id, name, description, price, prep_time_minutes, available_on, created_at, updated_at FROM dishes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDish(ctx context.Context, id pgtype.UUID) (Dish, error) {
	row := q.db.QueryRow(ctx, getDish, id)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.PrepTimeMinutes,
		&i.AvailableOn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDishByName = `-- name: GetDishByName :one
SELECT id, name, description, price, prep_time_minutes, available_on, created_at, updated_at FROM dishes
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetDishByName(ctx context.Context, name string) (Dish, error) {
	row := q.db.QueryRow(ctx, getDishByName, name)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.PrepTimeMinutes,
		&i.AvailableOn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDishesByDate = `-- name: GetDishesByDate :many
SELECT id, name, description, price, prep_time_minutes, available_on, created_at, updated_at FROM dishes
WHERE available_on = $1
ORDER BY name
`

func (q *Queries) GetDishesByDate(ctx context.Context, availableOn pgtype.Date) ([]Dish, error) {
	rows, err := q.db.Query(ctx, getDishesByDate, availableOn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dish
	for rows.Next() {
		var i Dish
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.PrepTimeMinutes,
			&i.AvailableOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByUserId = `-- name: GetNotificationsByUserId :many
SELECT id, user_id, order_id, message, sent_at FROM notifications
WHERE user_id = $1
`

func (q *Queries) GetNotificationsByUserId(ctx context.Context, userID pgtype.UUID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderID,
			&i.Message,
			&i.SentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT id, user_id, dish_id, status, created_at, updated_at FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DishID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrdersByDishId = `-- name: GetOrdersByDishId :many
SELECT id, user_id, dish_id, status, created_at, updated_at FROM orders
WHERE dish_id = $1
`

func (q *Queries) GetOrdersByDishId(ctx context.Context, dishID pgtype.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByDishId, dishID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DishID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatus = `-- name: GetOrdersByStatus :many
SELECT id, user_id, dish_id, status, created_at, updated_at FROM orders
WHERE status = $1
`

func (q *Queries) GetOrdersByStatus(ctx context.Context, status string) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DishID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserId = `-- name: GetOrdersByUserId :many
SELECT
    o.id, o.user_id, o.dish_id, o.status, o.created_at, o.updated_at,
    d.name as dish_name,
    d.description as dish_description,
    d.price as dish_price
FROM orders o
JOIN dishes d ON o.dish_id = d.id
WHERE o.user_id = $1
`

type GetOrdersByUserIdRow struct {
	ID              pgtype.UUID      `db:"id" json:"id"`
	UserID          pgtype.UUID      `db:"user_id" json:"user_id"`
	DishID          pgtype.UUID      `db:"dish_id" json:"dish_id"`
	Status          string           `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	DishName        string           `db:"dish_name" json:"dish_name"`
	DishDescription pgtype.Text      `db:"dish_description" json:"dish_description"`
	DishPrice       pgtype.Numeric   `db:"dish_price" json:"dish_price"`
}

func (q *Queries) GetOrdersByUserId(ctx context.Context, userID pgtype.UUID) ([]GetOrdersByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByUserIdRow
	for rows.Next() {
		var i GetOrdersByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DishID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DishName,
			&i.DishDescription,
			&i.DishPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissions = `-- name: GetPermissions :many
SELECT id, name FROM permissions
`

func (q *Queries) GetPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT role_id, permission_id FROM role_permissions
`

func (q *Queries) GetRolePermissions(ctx context.Context) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, getRolePermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RolePermission
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(&i.RoleID, &i.PermissionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoles = `-- name: GetRoles :many
SELECT id, name FROM roles
`

func (q *Queries) GetRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, getRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, name, email, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, created_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT user_id, role_id FROM user_roles
`

func (q *Queries) GetUserRoles(ctx context.Context) ([]UserRole, error) {
	rows, err := q.db.Query(ctx, getUserRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRole
	for rows.Next() {
		var i UserRole
		if err := rows.Scan(&i.UserID, &i.RoleID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishes = `-- name: ListDishes :many
SELECT id, name, description, price, prep_time_minutes, available_on, created_at, updated_at FROM dishes
ORDER BY created_at DESC
`

func (q *Queries) ListDishes(ctx context.Context) ([]Dish, error) {
	rows, err := q.db.Query(ctx, listDishes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dish
	for rows.Next() {
		var i Dish
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.PrepTimeMinutes,
			&i.AvailableOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDish = `-- name: UpdateDish :one
UPDATE dishes
SET
    name = $2,
    description = $3,
    price = $4,
    prep_time_minutes = $5,
    available_on = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, prep_time_minutes, available_on, created_at, updated_at
`

type UpdateDishParams struct {
	ID              pgtype.UUID    `db:"id" json:"id"`
	Name            string         `db:"name" json:"name"`
	Description     pgtype.Text    `db:"description" json:"description"`
	Price           pgtype.Numeric `db:"price" json:"price"`
	PrepTimeMinutes int32          `db:"prep_time_minutes" json:"prep_time_minutes"`
	AvailableOn     pgtype.Date    `db:"available_on" json:"available_on"`
}

func (q *Queries) UpdateDish(ctx context.Context, arg UpdateDishParams) (Dish, error) {
	row := q.db.QueryRow(ctx, updateDish,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.PrepTimeMinutes,
		arg.AvailableOn,
	)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.PrepTimeMinutes,
		&i.AvailableOn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, dish_id, status, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	Status string      `db:"status" json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DishID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name = $2, email = $3
WHERE id = $1
RETURNING id, name, email, created_at
`

type UpdateUserParams struct {
	ID    pgtype.UUID `db:"id" json:"id"`
	Name  string      `db:"name" json:"name"`
	Email string      `db:"email" json:"email"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.Name, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}
